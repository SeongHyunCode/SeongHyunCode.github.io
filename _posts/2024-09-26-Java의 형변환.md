---
title: Java의 형변환에 대해 알아보자
date: 2024-09-26 11:10:33 +09:00
categories: [Java]
tags:
    [
        Java,
    ]
---

# 서론  

**float** 으로 선언된 변수를 **double** 로 형변환을 해보자.  

프로그래밍 언어에서 **float** 은 32비트 부동소수점을 나타내며, 소수점 이하 7자리 까지 정확히 표현할 수 있다.  

**float** 으로 선언하고 싶다면 뒤에 **F** 접미사를 붙여 이 변수는 **float** 타입임을 알려줘야 한다.  

접미사를 붙이지 않았다면 자동으로 **double** 로 인식이 된다.  

**double** 은 64비트 부동소수점을 나타내며, 소수점 이하 15자리 까지 정확히 표현할 수 있다.  

보통 소수를 사용할 일이 있으면 거진 **double** 로 선언을 한다.  

## 코드  

~~~java
public class Conversion {
    public static void main(String[] args){
        float floatValue = 1.12F;
        double doubleValue = floatValue;
        System.out.println(floatValue);
        System.out.println(doubleValue);
    }
}
~~~  

## 결과  

~~~
1.12
1.1200000047683716
~~~  

변수 **floatValue** 에는 1.12의 값을 넣어주고, **doubleValue** 변수에는 1.12의 값이 저장되어있는 **flaotValue** 를 넣어준다.  

두 변수를 출력 했을 때 둘 다 1.12로 나와야 할 것 같지만 **floatValue** 만 1.12로 나오고 **doubleValue** 에는 1.12뒤에 **00000047683716** 가 추가로 출력되었다.  

이는 **부동소수점** 의 문제 때문이다.  

1.12라는 숫자는 10진수에서는 간단한 숫자이지만, 컴퓨터는 소수를 2진수로 변환해서 계산하기 때문에 이를 2진수로 변환하면 무한한 값이 된다.  

부동소수점 숫자는 유한한 비트 수로만 표현되기 때문에, 이 숫자를 32비트 또는 64비트로 자르게 된다.  

이로 인해 정확한 값이 아닌 근사값이 저장됩니다.  

실제로 **floatValue** 에는 1.1200000047683715... 의 값이 저장되어 있지만 표현의 한계로 1.12를 출력하는 것이며, **double** 은 더 많은 소수점을 표현할 수 있기에 위와 같은 결과가 나오는 것이다.  

이것이 부동소수점 표현의 한계이며 Java뿐만 아니라 여러 프로그래밍 언어에서도 공통적으로 이러한 문제가 발생한다.  

# 결론  
오늘은 Java의 형변환에 대해 간단하게 알아보았다.