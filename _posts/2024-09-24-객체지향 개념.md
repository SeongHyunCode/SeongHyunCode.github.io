---
title: 객체지향의 개념에 대해 알아보자2
date: 2024-09-24 12:10:33 +09:00
categories: [Java]
tags:
    [
        Java,
        정의
    ]
---

# 서론  

지난 글에서 **객체지향** 의 **객체(Object), 캡슐화(Encapsulation)** 에 대해서 알아보았다.  

이번 글에서는 **상속(Inheritance), 다형성(Polymorphism)** 에 대해 알아보자.  

## 상속(Inheritance)  

**상속** 이란 간단히 말해 **부모 객체**로부터 데이터들을 물려 받을 수 있는 기능이다.  

데이터를 물려 받은 **자식 클래스**는 **부모 클래스**의 기능을 대신 할 수 있다.  

**상속**을 이용하여 얻을 수 있는 장점은 다음과 같다.  
* 코드의 재사용성
* 유지 보수성
* 확장성 

**객체지향**에서 상속의 주요 개념은 다음과 같다.  

1. **extends**: **Java**기준으로 클래스가 다른 클래스를 상속받기 위해서는 **extends** 키워드를 사용해야 한다.  

2. **코드 재사용**: **자식 클래스**는 **부모 클래스**의 **필드**와 **메서드**를 그대로 사용할 수 있다.  
   **상속**을 통해 **자식 클래스**는 **부모 클래스**의 기능을 물려받아 코드의 중복을 줄일 수 있다.  

3. **Overriding**: **자식 클래스**는 **부모 클래스**에서 상속받은 메서드를 **재정의(Override)** 할 수 있다.  
    오버라이딩할 때는 **@Override** 이너테이션을 사용해 명시적으로 알리는 것이 좋다.

4. **super**: **자식 클래스**에서 **부모 클래스**의 생성자나 메서드를 호출할 때 **super** 키워드를 사용한다.  
   **super()** 는 부모 클래스의 생성자를 호출하고, **super.메서드()** 는 부모 클래스의 메서드를 호출한다.

5. **접근 제어자**: 부모 클래스의 멤버에 대한 접근은 접근 제어자에 따라 달라진다.  
* public: 모든 클래스에서 접근 가능.
* protected: 상속받은 자식 클래스 또는 같은 패키지 내에서 접근 가능.
* private: 부모 클래스 내부에서만 접근 가능. (자식 클래스에서도 접근이 불가능하다.)  

6. **단일 상속**: Java는 **단일 상속**만 지원한다.  
   즉, 하나의 자식 클래스는 오직 하나의 부모 클래스만 상속받을 수 있다.  
   다중 상속은 Java에서 허용되지 않는다.  
   하지만, 하나의 클래스에서 여러 인터페이스를 구현할 수는 있다.  
   사실 클래스는 슈퍼 클래스를 명시하지 않아도 암시적으로 객체 클래스의 서브 클래스로 선언되기 때문에 하나의 클래스를 항상 **상속**하고 있다고 봐도 된다.  

### 상속 예제 코드
**부모 클래스**
~~~java
class Car {
    String name;

    public Car(String name) {
        this.name = name;
    }

    public void brake() {
        System.out.println(name + "이(가) 멈췄습니다.");
    }
}
~~~

**자식 클래스**
~~~java
class Bus extends Car {

    public Bus(String name) {
        super(name);
    }

    @Override
    public void brake() {
        System.out.println(name + "이(가) 천천히 멈췄습니다.");
    }
}

class LightCar extends Car {

    public LightCar(String name) {
        super(name);
    }

    @Override
    public void brake() {
        System.out.println(name + "이(가) 빠른 속도로 멈췄습니다.");
    }
}
~~~  

**main** 
~~~java
public class Main {
    public static void main(String[] args) {
        Bus bus = new Bus("카운티");
        LightCar lightCar = new LightCar("모닝");

        bus.brake();
        lightCar.brake();
    }
}
~~~  

### 결과
~~~
카운티이(가) 천천히 멈췄습니다.
모닝이(가) 빠른 속도로 멈췄습니다.
~~~  

## 다형성(Polymorphism)  

**다형성** 이란 같은 타입의 객체가 다양한 방식으로 동작할 수 있는 성질을 의미한다.  

**다형성**은 주로 **상속**과 **인터페이스**를 통해 구현되며, 코드의 유연성을 높이고, 확장성과 유지보수를 쉽게 만든다.  

**다형성**은 **정적 바인딩** 과 **동적 바인딩** 으로 나뉜다.  

* **정적 바인딩**: 컴파일 시점에 결정되는 다형성
* **동적 바인딩**: 실행 시점에 결정되는 다형성

### 다형성 예제 코드
~~~java
class Car {
    public void brake() {
        System.out.println("자동차가 멈춥니다.");
    }
}

class Bus extends Car {
    @Override
    public void brake() {
        System.out.println("버스가 천천히 멈춥니다.");
    }
}

class LightCar extends Car {
    @Override
    public void brake() {
        System.out.println("경차가 빠른 속도로 멈춥니다.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car();
        Car myBus = new Bus();
        Car myLightCar = new LightCar();

        myCar.brake();
        myDog.brake();
        myCat.brake();
    }
}
~~~

### 결과
~~~
자동차가 멈춥니다.
버스가 천천히 멈춥니다.
경차가 빠른 속도로 멈춥니다.
~~~  

# 결론  

오늘은 객체지향의 개념 중 **상속** 과 **다형성** 에 대해 알아보았다.  

사실 여러 객체지향 언어들에서 구현하는 방법만 조금씩 다르다 뿐이지 큰 틀은 모두 비슷하기 때문에 하나를 제대로 배워 놓으면 다른 언어를 배울 때는 그렇게 어렵게 느껴지지 않는다.